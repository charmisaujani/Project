# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TkfWxn0C97_DbjRaPzOA5bU6pKGgexQE
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import datetime as dt
from pandas_datareader import data as pdr
import yfinance as yf

def get_data(stocks, start, end):
  stockData = yf.download(stocks, start, end)
  stockData = stockData['Close']
  returns = stockData.pct_change()
  meanReturns = returns.mean()
  covMatrix = returns.cov()
  return meanReturns, covMatrix

stockList = ['CBA', 'BHP', 'TLS', 'NAB', 'WBC', 'STO']
stocks = [stock + '.AX' for stock in stockList]
endDate = dt.datetime.now()
startDate = endDate - dt.timedelta(days = 300)

meanReturns, covMatrix = get_data(stocks, startDate, endDate)
print(meanReturns)

weights = np.random.random(len(meanReturns))
weights /= np.sum(weights)

print(weights)

"""Monte Carlo Method

Assuming daily returns are distributed by a multivariate normal distribution.
Cholesky Decomposition is used to determine teh lower traingle matrix

Rt = mu + L*Zt

Zt ~ N(0,I) : samples from a normal distribution (I is identity matrix)
"""

mc_sims = 100
T = 100 #timeperiod in days

meanM = np.full(shape = (T, len(weights)), fill_value= meanReturns)
meanM = meanM.T

portfolio_sims = np.full(shape=(T, mc_sims), fill_value = 0.0)

initialPortfolio = 10000

for m in range(0, mc_sims):
  Z = np.random.normal(size = (T, len(weights)))
  L = np.linalg.cholesky(covMatrix)
  dailyReturns = meanM + np.inner(L, Z)
  portfolio_sims[:, m] = np.cumprod(np.inner(weights, dailyReturns.T)+ 1)*initialPortfolio

plt.plot(portfolio_sims)
plt.ylabel('Portfolio Value ($)')
plt.xlabel('Days')
plt.title('MC Simulation of a stock portfolio')
plt.show()